<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bayesian posterior simulations and predictive checks • mgcViz</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Bayesian posterior simulations and predictive checks">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">mgcViz</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/BayesPost.html">Bayesian posterior simulations and predictive checks</a>
    </li>
    <li>
      <a href="../articles/mgcviz.html">An introduction to mgcViz: visual tools for GAMs</a>
    </li>
    <li>
      <a href="../articles/miscellanea.html">Miscellanea: things you can do in mgcViz</a>
    </li>
    <li>
      <a href="../articles/qgam_mgcViz.html">Quantile additive models using qgam and mgcViz</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mfasiolo/mgcViz">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Bayesian posterior simulations and predictive checks</h1>
                        <h4 class="author">Matteo Fasiolo</h4>
            
            <h4 class="date">December 06 2018</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mfasiolo/mgcViz/blob/master/vignettes/BayesPost.Rmd"><code>vignettes/BayesPost.Rmd</code></a></small>
      <div class="hidden name"><code>BayesPost.Rmd</code></div>

    </div>

    
    
<style>
body {
text-align: justify}
</style>
<div id="posterior-simulation-and-checking-methods" class="section level1">
<h1 class="hasAnchor">
<a href="#posterior-simulation-and-checking-methods" class="anchor"></a>Posterior simulation and checking methods</h1>
<div id="smooth-effects-simulations" class="section level2">
<h2 class="hasAnchor">
<a href="#smooth-effects-simulations" class="anchor"></a>Smooth effects simulations</h2>
<p>As of version 0.1.3, the <code>mgcViz</code> R package (Fasiolo et al., 2018) includes some methods for posterior simulation. Here we describe how to simulate and visualize one dimensional smooth effects. We start by simulating Gaussian data from a standard GAM example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mgcViz)
<span class="kw">set.seed</span>(<span class="dv">49</span>)
dat &lt;-<span class="st"> </span><span class="kw">gamSim</span>(<span class="dv">1</span>,<span class="dt">n=</span><span class="dv">400</span>,<span class="dt">dist=</span><span class="st">"normal"</span>,<span class="dt">scale=</span><span class="dv">2</span>, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
b &lt;-<span class="st"> </span><span class="kw"><a href="../reference/gamV.html">gamV</a></span>(y~<span class="kw">s</span>(x0)+<span class="kw">s</span>(x1)+<span class="kw">s</span>(x2)+<span class="kw">s</span>(x3), <span class="dt">data=</span>dat)</code></pre></div>
<p>To plot the first smooth effect, together with some posterior simulations, we can do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw"><a href="../reference/sm.html">sm</a></span>(b, <span class="dv">1</span>), <span class="dt">nsim =</span> <span class="dv">20</span>) +<span class="st"> </span><span class="kw"><a href="../reference/l_ciLine.html">l_ciLine</a></span>() +<span class="st"> </span><span class="kw"><a href="../reference/l_fitLine.html">l_fitLine</a></span>() +<span class="st"> </span><span class="kw"><a href="../reference/l_simLine.html">l_simLine</a></span>()</code></pre></div>
<p><img src="BayesPost_files/figure-html/simSmooth2-1.png" width="700" style="display:block; margin: auto"> Here the argument <code>nsim</code> is used to specify the number of posterior simulations to perform for this smooth and <code>l_simLine</code> is the layer used to plot the simulated smooths.</p>
<p>One reference supporting the use of posterior simulations for smooth effect uncertainty assessment is Bowman (2018), who also argues in favour of the use of “density strips” as alternative to the traditional mean + confidence interval effects plots, such as the one above. The <code>l_fitDens</code> layer can be used to add a conditional posterior density strip to 1D smooth effects plots, where the opacity is proportional to the conditional posterior density of the fitted effect, under the usual Gaussian approximation to the posterior. Here is an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw"><a href="../reference/sm.html">sm</a></span>(b, <span class="dv">1</span>), <span class="dt">nsim =</span> <span class="dv">20</span>) +<span class="st"> </span><span class="kw"><a href="../reference/l_fitDens.html">l_fitDens</a></span>() +<span class="st"> </span><span class="kw"><a href="../reference/l_simLine.html">l_simLine</a></span>(<span class="dt">colour =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/simSmooth3-1.png" width="700" style="display:block; margin: auto"></p>
<p>Of course these methods can be applied to all the one dimensional smooth contained in the model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pl &lt;-<span class="st"> </span><span class="kw">plot</span>(b, <span class="dt">nsim =</span> <span class="dv">20</span>) +<span class="st"> </span><span class="kw"><a href="../reference/l_fitDens.html">l_fitDens</a></span>() +<span class="st"> </span><span class="kw"><a href="../reference/l_simLine.html">l_simLine</a></span>(<span class="dt">colour =</span> <span class="dv">1</span>) +<span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">"none"</span>)
<span class="kw">print</span>(pl, <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/simSmooth4-1.png" width="700" style="display:block; margin: auto"></p>
</div>
<div id="bayesian-posterior-predictive-checks" class="section level2">
<h2 class="hasAnchor">
<a href="#bayesian-posterior-predictive-checks" class="anchor"></a>Bayesian posterior predictive checks</h2>
<p>Performing posterior predictive checks is important in the Bayesian modelling workflow, as explained for instance in Gabry (2019). There are several methods for performing posterior checks in <code>mgcViz</code>. We’ll start with in-sample checks, that is checks that compare the distribution of the observed responses <span class="math inline">\(y\)</span> with that of the posterior simulations <span class="math inline">\(\tilde{y}\)</span> given the covariates <span class="math inline">\(x\)</span>, where both <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> come from the training set (i.e. they have been used to estimate the model). Consider the following example, where the residuals variance depends on covariate <code>x2</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mgcViz)
<span class="co"># Simulate some data</span>
n  &lt;-<span class="st"> </span><span class="fl">1e3</span>
dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="st">"x1"</span> =<span class="st"> </span><span class="kw">runif</span>(n, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="st">"x2"</span> =<span class="st"> </span><span class="kw">runif</span>(n, -<span class="dv">1</span>, <span class="dv">1</span>))
dat$y &lt;-<span class="st"> </span><span class="kw">with</span>(dat, <span class="kw">sin</span>(<span class="dv">3</span>*x1) +<span class="st"> </span><span class="fl">0.5</span> *<span class="st"> </span>x2^<span class="dv">2</span> +<span class="st"> </span><span class="kw">pmax</span>(x2, <span class="fl">0.2</span>) *<span class="st"> </span><span class="kw">rnorm</span>(n))

<span class="co"># Fit model and convert to "gamViz" object</span>
b &lt;-<span class="st"> </span><span class="kw">gam</span>(y ~<span class="st"> </span><span class="kw">s</span>(x1)+<span class="kw">s</span>(x2), <span class="dt">data =</span> dat)
b &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getViz.html">getViz</a></span>(b, <span class="dt">nsim =</span> <span class="dv">100</span>, <span class="dt">post =</span> <span class="ot">TRUE</span>, <span class="dt">unconditional =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>The arguments of <code>gam</code> should be familiar, while in the call to <code>getViz</code> we used:</p>
<ul>
<li>
<code>nsim</code>: the number of posterior response simulations to be performed;</li>
<li>
<code>post = TRUE</code>: specifies that we want each vector of responses to be simulated using a different vector of parameters, which has been simulated from a Gaussian approximation to the posterior (see <code><a href="../reference/getViz.html">?getViz</a></code> for details);</li>
<li>
<code>unconditional = TRUE</code>: will be passed down to the <code>vcov.gam</code> function, and indicates that we want smoothing parameter uncertainty to be taken into account when simulating the parameter vectors from the posterior (see <code>?vcov.gam</code> for details).</li>
</ul>
<p>Now, <code>b</code> contains <code>nsim</code> vectors of <span class="math inline">\(n = 10^3\)</span> responses simulated from the predictive posterior, which can be used to perform posterior model checks. We start with the simplest available method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check0D.html">check0D</a></span>(b) +<span class="st"> </span><span class="kw"><a href="../reference/l_hist.html">l_hist</a></span>()</code></pre></div>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="BayesPost_files/figure-html/predCheck2-1.png" width="700" style="display:block; margin: auto"> Here we are comparing the empirical distribution of the observed residuals with that of the simulated ones, and it seems that the observed residuals distribution has fatter tails. To verify this, we can compare the 4th central moments of the observed and simulated residuals by doing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check0D.html">check0D</a></span>(b, <span class="dt">trans =</span> function(.y) <span class="kw">mean</span>((.y -<span class="st"> </span><span class="kw">mean</span>(.y))^<span class="dv">4</span>)) +<span class="st"> </span><span class="kw"><a href="../reference/l_hist.html">l_hist</a></span>() +<span class="st"> </span><span class="kw"><a href="../reference/l_vline.html">l_vline</a></span>()</code></pre></div>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="BayesPost_files/figure-html/predCheck3-1.png" width="700" style="display:block; margin: auto"> Here the histogram shows the distribution of the <code>nsim = 100</code> simulated empirical 4th moments, while the vertical line is the 4th moment of the observed residuals. It is clear that the observed residuals have fatter tails.</p>
<p>Before concluding that we should use a fatter-tailed response distribution (e.g. a Student’s t), we verify whether the distribution of the residuals changes along some of the variables included in the model. In particular, we do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(b, <span class="st">"x2"</span>) +<span class="st"> </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(sd, <span class="dt">level =</span> <span class="fl">0.95</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck4-1.png" width="700" style="display:block; margin: auto"> Here the red intervals are a 95% posterior credible intervals for the residuals standard deviation, computed using the posterior simulations, while the black points are the standard deviation of the observed binned residuals (see <code><a href="../reference/l_gridCheck1D.html">?l_gridCheck1D</a></code> for details). It is clear that the residual variance increases for <code>x2 &gt; 0.2</code>, as almost all points fall outside the credible intervals. Notice that the credible intervals computed using <code>post = TRUE</code> should be larger then those computing by setting <code>post = FALSE</code> (the default), because they take into account posterior parameter uncertainty. Similarly setting <code>unconditional = TRUE</code> should lead to slightly wider intervals, because smoothing parameter uncertainty is taken into account.</p>
<p>Before adressing the non-constant variance problem by using a more flexible model, notice that <code>check1D</code> is vectorized in the <code>x</code> argument, that is we can do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw"><a href="../reference/check1D.html">check1D</a></span>(b, <span class="dt">x =</span> <span class="kw">list</span>(<span class="st">"x1"</span>, <span class="st">"x2"</span>), <span class="dt">type =</span> <span class="st">"tnorm"</span>) +<span class="st"> </span><span class="kw"><a href="../reference/l_densCheck.html">l_densCheck</a></span>(), <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck5-1.png" width="960" style="display:block; margin: auto"> Hence we can pass a list of variables names to <code>check1D</code>, which will produce a checking plot for each variable. Vectorization will also work if we pass a list of numeric vectors of the same length (for instance <code>check1D(b, list(dat$x1, dat$x2)</code>). Here the same <code>l_densCheck</code> layer has been used on both plots. The heatmap is red (blue) if the density of the observed residuals is lower than the model-based residual density (which is a standard normal here, because we are transforming the residuals to normal using <code>type = tnorm</code>). The plot on the left shows that the residuals have fatter tails across <code>x1</code> (relative to what would be expected under a N(0,1) distribution), while the plot on the right shows the variance of the residuals is lower than expected for <code>x2 &lt; 0.2</code> and too high for <code>x2 &gt; 0.2</code>. See <code><a href="../reference/l_densCheck.html">?l_densCheck</a></code> for details.</p>
<p>The non-constant residual variance problem can be fixed by adopting a more flexible mean-variance Gaussian model (see <code>?gaulss</code> for details):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/gamV.html">gamV</a></span>(<span class="kw">list</span>(y ~<span class="st"> </span><span class="kw">s</span>(x1)+<span class="kw">s</span>(x2), ~<span class="st"> </span><span class="kw">s</span>(x2)), <span class="dt">data =</span> dat, <span class="dt">family =</span> gaulss,
           <span class="dt">aViz =</span> <span class="kw">list</span>(<span class="dt">nsim =</span> <span class="dv">100</span>, <span class="dt">post =</span> <span class="ot">TRUE</span>, <span class="dt">unconditional =</span> <span class="ot">TRUE</span>))</code></pre></div>
<p>where now we are usign the <code>gamV</code> shortcut, which first fits the model using <code>gam</code> and then it converts the fitted models using <code>getViz</code>. The <code>aViz</code> argument is a list or arguments which will be passed to <code>getViz</code>. We can then repeat the checks, for instance:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check0D.html">check0D</a></span>(b1) +<span class="st"> </span><span class="kw"><a href="../reference/l_hist.html">l_hist</a></span>()</code></pre></div>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="BayesPost_files/figure-html/predCheck7-1.png" width="700" style="display:block; margin: auto"> which now looks fine.</p>
<p>To illustrate how to perform out-of-sample checks, assume that we have a testing set simulated as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datTest &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="st">"x1"</span> =<span class="st"> </span><span class="kw">runif</span>(n, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="st">"x2"</span> =<span class="st"> </span><span class="kw">runif</span>(n, -<span class="dv">1</span>, <span class="dv">1</span>))
datTest$y &lt;-<span class="st"> </span><span class="kw">with</span>(datTest, <span class="fl">0.5</span> *<span class="st"> </span>x2^<span class="dv">2</span> +<span class="st"> </span><span class="kw">pmax</span>(x2, <span class="fl">0.2</span>) *<span class="st"> </span><span class="kw">rnorm</span>(n)) <span class="co"># Effect sin(3*x1) removed!</span></code></pre></div>
<p>and notice that we have removed the effect of variable <code>x1</code>, so that the model fitted on the original data set is not adequate for the testing set (but assume we don’t know it!).</p>
<p>To perform posterior predictive checks on the test set, we first need to perform some simulations using the new data set. This is done using the <code>newdata</code> argument in <code>getViz</code>, that is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getViz.html">getViz</a></span>(b1, <span class="dt">nsim =</span> <span class="dv">100</span>, <span class="dt">post =</span> <span class="ot">TRUE</span>, <span class="dt">unconditional =</span> <span class="ot">TRUE</span>, <span class="dt">newdata =</span> datTest)</code></pre></div>
<p>Having performed the simulations, we can compare the means of the (binned) observed and simulated residuals distributions along each variable:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw"><a href="../reference/check1D.html">check1D</a></span>(b1, <span class="kw">list</span>(<span class="st">"x1"</span>, <span class="st">"x2"</span>)) +<span class="st"> </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(mean, <span class="dt">level =</span> <span class="fl">0.95</span>), <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck10-1.png" width="960" style="display:block; margin: auto"><strong>One important thing</strong> to point out is that the y-axis is labelled <code>y</code> here, not <code>r</code> as in previous calls to <code>check1D</code>. This is because <code>b1</code> contains simulations based a new data set and, when this is the case, <code>check1D</code> does not transform the response <span class="math inline">\(y\)</span> to residuals <span class="math inline">\(r\)</span>, but works directly on <span class="math inline">\(y\)</span>. This somewhat inconsistent behaviour is due to the fact that it is difficult to develop code that transforms responses to residuals using new data, given that the implementation of the residuals function depends on the family used in the <code>gam</code> call and often uses quantities defined inside the fitted <code>gamObject</code>.</p>
<p>However, to perform the checks on residuals it is sufficient to provide <code>check1D</code> with a function that will transform the responses to the chosen residuals type. For instance, we can create a transformation function as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">getResFun &lt;-<span class="st"> </span>function(o, newd){

  <span class="co"># Fooling the gamObject "o" by changing ... </span>
  o$fitted.values &lt;-<span class="st"> </span><span class="kw">predict</span>(o, <span class="dt">newdata =</span> newd) <span class="co"># ... fitted values</span>

  resFun &lt;-<span class="st"> </span>function(y){
    o$y &lt;-<span class="st"> </span>y                <span class="co"># ... and responses</span>
    out &lt;-<span class="st"> </span>o$family$<span class="kw">residuals</span>(o)
    <span class="kw">return</span>( out )
  }

  <span class="kw">return</span>( resFun )
}

resFun &lt;-<span class="st"> </span><span class="kw">getResFun</span>(<span class="dt">o =</span> b1, <span class="dt">newd =</span> datTest)</code></pre></div>
<p>Here, importantly, we are calling predict only once (when <code>resFun</code> is created), thus avoiding calling <code>predict</code> every time that <code>resFun</code> is called (it will be called <code>nsim</code> times by <code>check1D</code> to transform the simulated responses). Then we call <code>check1d</code> again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(b1, <span class="kw">list</span>(<span class="st">"x1"</span>, <span class="st">"x2"</span>), <span class="dt">trans =</span> resFun)
<span class="kw">print</span>(pl, <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck12-1.png" width="960" style="display:block; margin: auto"> Here we have not explicitly added the <code>l_gridCheck1D</code> layer, so some default layers are added when the output of <code>check1D</code> is printed. In particular the last two plots could be reproduced exactly by doing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(b1, <span class="kw">list</span>(<span class="st">"x1"</span>, <span class="st">"x2"</span>), <span class="dt">trans =</span> resFun) +<span class="st"> </span><span class="kw"><a href="../reference/l_dens2D.html">l_dens2D</a></span>(<span class="st">"cond"</span>) +<span class="st"> </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(mean, <span class="dt">showReps =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(pl, <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p>where <code>l_dens2D</code> adds a heatmap representing the conditional density of the residuals <span class="math inline">\(p(y|x)\)</span>. Anyway, here the observed residuals show an anomalous sinusoidal pattern, which due to the fact that the training and test set have been generated using different mean models.</p>
<p>The fact that we supplied <code>newdata</code> in the call to <code>getViz</code> or <code>gamV</code> will be taken into account also by the <code>check0D</code> and <code>check2D</code> methods. In fact the code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check0D.html">check0D</a></span>(b1, <span class="dt">trans =</span> resFun) +<span class="st"> </span><span class="kw"><a href="../reference/l_dens1D.html">l_dens1D</a></span>()</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck14-1.png" width="700" style="display:block; margin: auto"> compares the distribution of observed and simulated residuals, both computed using covariates and responses the test data set. Same for <code>check2D</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check2D.html">check2D</a></span>(b1, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="dt">trans =</span> resFun)</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck15-1.png" width="700" style="display:block; margin: auto"> Where the <code><a href="../reference/l_gridCheck2D.html">l_gridCheck2D()</a></code> layer has been added by default when the output of <code>check2D</code> is printed. To avoid this you can add some layer (such as <code>l_rug</code>) or tell <code>print</code> not to add any layer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw"><a href="../reference/check2D.html">check2D</a></span>(b1, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="dt">trans =</span> resFun), <span class="dt">addLay =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/predCheck15b-1.png" width="192" style="display:block; margin: auto"> which indeed produces an empty plot.</p>
<p>If we want to remove the test set from our object (because, for instance, we want to perform diagnostics on the training set), we just need to do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getViz.html">getViz</a></span>(b1)</code></pre></div>
<pre><code>## getViz: newdata removed from gamViz object</code></pre>
<p>where we have left the <code>newdata</code> argument unspecified. Notice that at any call to <code>getViz</code> the simulated responses will be removed, so at the moment <code>b1</code> does not contain any posterior simulation.</p>
</div>
<div id="generating-raw-predictive-posterior-simulations" class="section level2">
<h2 class="hasAnchor">
<a href="#generating-raw-predictive-posterior-simulations" class="anchor"></a>Generating “raw” predictive posterior simulations</h2>
<p>In the examples shown above the posterior simulations where generated by <code>getViz</code> and then processed by the <code>check0D</code>, <code>check1D</code> and <code>check2D</code> methods. However, the responses are actually simulated by the <code>postSim</code> function, which is called by <code>getViz</code>. Hence, if you just want to simulate some responses from the predictive posterior, you should use this function. Here is an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mgcViz)
<span class="kw">library</span>(MASS)
b &lt;-<span class="st"> </span><span class="kw">gam</span>(accel~<span class="kw">s</span>(times, <span class="dt">k=</span><span class="dv">20</span>), <span class="dt">data=</span>mcycle)

n &lt;-<span class="st"> </span><span class="dv">10</span>
sim &lt;-<span class="st"> </span><span class="kw"><a href="../reference/postSim.html">postSim</a></span>(<span class="dt">o =</span> b, <span class="dt">nsim =</span> n, <span class="dt">method =</span> <span class="st">"qf"</span>, <span class="dt">unconditional =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>The output, <code>sim</code>, is a matrix where each row contains a vectors of responses, simulated using a vector of regression coefficients simulated from a Gaussian approximation to the posterior. As before the <code>unconditional</code> argument is passed to <code>vcov.gam</code>, while <code>method</code> is passed to <code>simulate.gam</code> and indicates the response simulation method used. Notice that <code>postSim</code> and <code>simulate.gam</code> (which simulates responses for fixed parameters) work directly on the output of <code>gam</code>, hence it is not necessary to use <code>getViz</code> to transform a <code>gamObject</code> into a <code>gamViz</code> object (or to use the <code>gamV</code> shortcut).</p>
<p>It is also possible to store the simulated vectors of regression coefficients and to transform the simulated responses, using the <code>savePar</code> and <code>trans</code> arguments, that is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/postSim.html">postSim</a></span>(<span class="dt">o =</span> b, <span class="dt">nsim =</span> n, <span class="dt">savePar =</span> <span class="ot">TRUE</span>, <span class="dt">trans =</span> function(x) <span class="kw">c</span>(<span class="kw">mean</span>(x), <span class="kw">var</span>(x)))

<span class="kw">str</span>(sim2)</code></pre></div>
<pre><code>## List of 2
##  $ simY   : num [1:10, 1:2] -30 -25.9 -25.8 -22.3 -26 ...
##  $ simBeta: num [1:10, 1:20] -26.8 -26 -24.8 -23.7 -26.2 ...</code></pre>
<p>Here <code>postSim</code> returns a list, where <code>simY</code> contains the simulated (transformed) responses and <code>simBeta</code> the simulated parameter vectors. The function <code>trans</code> can return either a vector or a scalar, and it can be useful when we want to save memory (for instance here we are storing only mean and variance of each simulated vector of responses).</p>
</div>
<div id="quantifying-prediction-error-under-custom-loss-functions" class="section level2">
<h2 class="hasAnchor">
<a href="#quantifying-prediction-error-under-custom-loss-functions" class="anchor"></a>Quantifying prediction error under custom loss functions</h2>
<p>The following section is somewhat out of place, because we don’t perform any posterior simulation here. But it still belongs here to some degree, as it focuses on model checking. In particular, the following explains how to assess the model’s in- or out-of-sample performance using loss functions. We start by simulating some data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">44</span>)
n &lt;-<span class="st"> </span><span class="fl">2e3</span>
datL &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">rnorm</span>(n), 
                   <span class="dt">y =</span> <span class="kw">rnorm</span>(n), 
                   <span class="dt">z =</span> <span class="kw">rnorm</span>(n), 
                   <span class="dt">fac =</span> <span class="kw">as.factor</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">5</span>, n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)))
datL$ob &lt;-<span class="st"> </span><span class="kw">with</span>(datL, <span class="kw">as.numeric</span>(fac) +<span class="st"> </span>(x)^<span class="dv">2</span> +<span class="st"> </span><span class="dv">4</span>*<span class="kw">sin</span>(x) +<span class="st"> </span>(y)^<span class="dv">2</span> +<span class="st"> </span>z +<span class="st"> </span><span class="fl">0.3</span>*z^<span class="dv">3</span> +<span class="st"> </span>
<span class="st">                      </span>(<span class="dv">2+2</span>*<span class="kw">as.numeric</span>(fac))  *<span class="st"> </span><span class="kw">rnorm</span>(n))</code></pre></div>
<p>Then we estimate the conditional quantile <span class="math inline">\(\tau = 0.3\)</span>, using a quantile GAM (QGAM) model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit &lt;-<span class="st"> </span><span class="kw">qgam</span>(ob ~<span class="st"> </span><span class="kw">s</span>(x) +<span class="st"> </span><span class="kw">s</span>(y) +<span class="st"> </span><span class="kw">s</span>(z) +<span class="st"> </span>fac, <span class="dt">qu =</span> <span class="fl">0.3</span>, <span class="dt">data =</span> datL)</code></pre></div>
<pre><code>## Estimating learning rate. Each dot corresponds to a loss evaluation. 
## qu = 0.3........done</code></pre>
<p>It is interesting to use a QGAM model in this section, because it is based on the so-call “pinball” loss function, not on a probabilistic model of the response distribution (see Koenker (2005) for an introduction to quantile regression and Fasiolo et al. (2017) for details on the QGAM methods used here). Because of this, performing posterior predictive checks by simulating responses from the model does not make sense (there is no model for <span class="math inline">\(p(y|x)\)</span>), and it is better to focus on the loss function of interest.</p>
<p>Suppose we have a test set, generated as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datT &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">rnorm</span>(n), 
                   <span class="dt">y =</span> <span class="kw">rnorm</span>(n), 
                   <span class="dt">z =</span> <span class="kw">rnorm</span>(n), 
                   <span class="dt">fac =</span> <span class="kw">as.factor</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">5</span>, n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)))
datT$ob &lt;-<span class="st"> </span><span class="kw">with</span>(datT, <span class="kw">as.numeric</span>(fac) +<span class="st"> </span>(x)^<span class="dv">2</span> -<span class="st"> </span><span class="dv">8</span>*<span class="kw">sin</span>(x) +<span class="st"> </span>(y)^<span class="dv">2</span> +<span class="st"> </span>z +<span class="st"> </span><span class="fl">0.3</span>*z^<span class="dv">3</span> +<span class="st"> </span><span class="co"># on training set -8*sin(x)</span>
<span class="st">                     </span>(<span class="dv">2+2</span>*<span class="kw">as.numeric</span>(fac))  *<span class="st"> </span><span class="kw">rnorm</span>(n))                          <span class="co"># was 4 * sin(x)</span></code></pre></div>
<p>where, for the purpose of illustration, the effect of variable <code>x</code> is different relative to the training set. To perform the checks, we first need to convert <code>fit</code> to a <code>gamViz</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getViz.html">getViz</a></span>(fit, <span class="dt">newdata =</span> datT)</code></pre></div>
<p>Then, calling <code>check0D</code> will provide a histogram of the observed residuals:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check0D.html">check0D</a></span>(fit) <span class="co"># + l_hist() layer added by default</span></code></pre></div>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="BayesPost_files/figure-html/checkLoss4-1.png" width="700" style="display:block; margin: auto"> which is not particularly interesting for QGAMs, because they are based on a loss function (hence we don’t expect the residuals to follow a normal or any other parametric distribution). To perform loss-based checks we need to define a loss function, and here the natural one is the pinball loss:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pinball &lt;-<span class="st"> </span>function(y, mu, qu){ <span class="co"># qu in quantile of interest</span>
  tau &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>qu
  d &lt;-<span class="st"> </span>y -<span class="st"> </span>mu
  l &lt;-<span class="st"> </span>d *<span class="st"> </span><span class="dv">0</span>
  l[d &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span>-<span class="st"> </span>tau*d[d&lt;<span class="dv">0</span>]
  l[d &gt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span>-<span class="st"> </span>(tau<span class="dv">-1</span>)*d[d&gt;<span class="dv">0</span>]
  <span class="kw">return</span>( l )
}</code></pre></div>
<p>which has the following shape:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
ys &lt;-<span class="st"> </span><span class="kw">seq</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dt">by=</span><span class="fl">0.01</span>)
<span class="kw">plot</span>(ys, <span class="kw">pinball</span>(ys, <span class="dv">0</span>, <span class="fl">0.1</span>), <span class="dt">type =</span> <span class="st">'l'</span>, <span class="dt">col =</span> <span class="dv">2</span>, <span class="dt">ylab =</span> <span class="st">"Pinball loss"</span>, <span class="dt">main =</span> <span class="kw">expression</span>(qu ==<span class="st"> </span><span class="fl">0.1</span>))
<span class="kw">plot</span>(ys, <span class="kw">pinball</span>(ys, <span class="dv">0</span>, <span class="fl">0.5</span>), <span class="dt">type =</span> <span class="st">'l'</span>, <span class="dt">col =</span> <span class="dv">2</span>, <span class="dt">ylab =</span> <span class="st">"Pinball loss"</span>, <span class="dt">main =</span> <span class="kw">expression</span>(qu ==<span class="st"> </span><span class="fl">0.5</span>))
<span class="kw">plot</span>(ys, <span class="kw">pinball</span>(ys, <span class="dv">0</span>, <span class="fl">0.9</span>), <span class="dt">type =</span> <span class="st">'l'</span>, <span class="dt">col =</span> <span class="dv">2</span>, <span class="dt">ylab =</span> <span class="st">"Pinball loss"</span>, <span class="dt">main =</span> <span class="kw">expression</span>(qu ==<span class="st"> </span><span class="fl">0.9</span>))</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss5b-1.png" width="960" style="display:block; margin: auto"> The loss can then be passed to <code>check0D</code>, which evaluates it at all data points:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check0D.html">check0D</a></span>(fit, 
        <span class="dt">type =</span> <span class="st">"y"</span>, 
        <span class="dt">trans =</span> function(x, ...) <span class="kw">pinball</span>(x, <span class="kw">predict</span>(fit, <span class="dt">newdata =</span> datT), <span class="dt">qu =</span> <span class="fl">0.3</span>)) +<span class="st"> </span>
<span class="st">        </span><span class="kw"><a href="../reference/l_dens1D.html">l_dens1D</a></span>() +<span class="st"> </span><span class="kw"><a href="../reference/l_rug.html">l_rug</a></span>() +<span class="st"> </span><span class="kw">xlab</span>(<span class="st">"Pinball loss"</span>) +<span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">"none"</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss6-1.png" width="700" style="display:block; margin: auto"> The output plot shows an estimate of the observed pinball loss distribution. <strong>Importantly</strong>, in the call to <code>check0D</code> we have set <code>type = "y"</code> to make sure that the transformation <code>trans</code> will be applied to the raw observed responses (otherwise <code>trans</code> would be applied to residuals, which doesn’t probably make sense).</p>
<p>To verify how the loss changes across the covariates we can do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(fit, 
              <span class="dt">x =</span> <span class="kw">list</span>(<span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"z"</span>), 
              <span class="dt">type =</span> <span class="st">"y"</span>, 
              <span class="dt">trans =</span>  function(x, ...) <span class="kw">pinball</span>(x, <span class="kw">predict</span>(fit, <span class="dt">newdata =</span> datT), <span class="dt">qu =</span> <span class="fl">0.3</span>)) +<span class="st"> </span>
<span class="st">              </span><span class="kw">geom_smooth</span>() +<span class="st"> </span>
<span class="st">              </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(<span class="dt">gridFun =</span> function(x, ...) <span class="kw">ifelse</span>(<span class="kw">length</span>(x) &gt;<span class="st"> </span><span class="dv">5</span>, <span class="kw">mean</span>(x), <span class="ot">NA</span>), <span class="dt">level =</span> <span class="dv">0</span>) +<span class="st"> </span>
<span class="st">              </span><span class="kw"><a href="../reference/l_rug.html">l_rug</a></span>() +<span class="st"> </span><span class="kw">ylab</span>(<span class="st">"Pinball loss"</span>)

<span class="kw">print</span>(pl, <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss7-1.png" width="700" style="display:block; margin: auto"> The plots wrt to <code>x</code> and shows that the pinball loss changes considerably along that covariate (which makes sense, given that the model is misspecified wrt <code>x</code>). There are several things that need to be explained here:</p>
<ul>
<li>we used <code>x = list("x", "y", "z")</code> to exploit the fact that <code>check1D</code> is vectorized wrt its <code>x</code> argument;</li>
<li>we used a mixture of layers coming from <code>mgcViz</code> (e.g. <code>l_gridCheck1D</code>) and <code>ggplot2</code> (e.g. <code>geom_smooth</code>);</li>
<li>we set <code>level = 0</code> in the call to <code>l_gridCheck1D</code> to indicate that we don’t want to plot confidence intervals, because these are typically calculated using simulated residuals (and here we have not simulated any);</li>
<li>given that the black points (the mean pinball loss in each bin) don’t have any uncertainty information associated with them, we return NA when there are less than 5 observations in a bin to avoid plotting outliers (which could be misleading);</li>
<li>again, we need to set <code>type = "y"</code> in the call to <code>check1D</code> for the loss-function-based transformation to make sense.</li>
</ul>
<p>We can also check how the out-of-sample pinball loss varies across the factor variable levels:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(fit, <span class="st">"fac"</span>, <span class="dt">type =</span> <span class="st">"y"</span>, 
        <span class="dt">trans =</span>  function(x) <span class="kw">pinball</span>(x, <span class="kw">predict</span>(fit, <span class="dt">newdata =</span> datT), <span class="dt">qu =</span> <span class="fl">0.3</span>), <span class="dt">useSim =</span> <span class="ot">FALSE</span>) +<span class="st"> </span>
<span class="st">        </span><span class="kw"><a href="../reference/l_rug.html">l_rug</a></span>(<span class="dt">sides =</span> <span class="st">"b"</span>) +<span class="st"> </span><span class="kw">geom_boxplot</span>() +<span class="st"> </span><span class="kw">ylab</span>(<span class="st">"Pinball loss"</span>) </code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss8-1.png" width="700" style="display:block; margin: auto"> This plot shows that the pinball losses are getting larger along the factor levels, which makes sense given that the variance of the response is proportional to it (see the code used to simulate the data, above).</p>
<p>It is useful to point out at this point that you can use the <code>listLayer</code> function to get a list of the <code>mgcViz</code> layers that can be used with a particular plot, for instance:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/listLayers.html">listLayers</a></span>( <span class="kw"><a href="../reference/check1D.html">check1D</a></span>(fit, <span class="st">"x"</span>, <span class="dt">type =</span> <span class="st">"y"</span>) )</code></pre></div>
<pre><code>## [1] "l_dens2D"       "l_densCheck"    "l_gridCheck1D"  "l_gridQCheck1D"
## [5] "l_points"       "l_rug"</code></pre>
<p>However notice that, while something like <code>check1D(fit, "x", type = "y") + l_densCheck()</code> would work here, the resulting plot would probably not be useful (we would be comparing the conditional density of the observed pinball losses with a standard normal, see <code>?densCheck</code>). Hence, whether a particular layer is useful depends on the response transformation used, on the chosen model (e.g. GAM vs QGAM), etc.</p>
<p>We can also look at how the pinball loss on the test set changes across each pair of covariates:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plJo &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check2D.html">check2D</a></span>(fit, <span class="kw">list</span>(<span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"z"</span>, <span class="st">"fac"</span>), <span class="dt">type =</span> <span class="st">"y"</span>, 
                <span class="dt">trans =</span> function(x) <span class="kw">pinball</span>(x, <span class="kw">predict</span>(fit, <span class="dt">newdata =</span> datT), <span class="dt">qu =</span> <span class="fl">0.3</span>)) +<span class="st"> </span>
<span class="st">                </span><span class="kw"><a href="../reference/l_gridCheck2D.html">l_gridCheck2D</a></span>(function(.x) <span class="kw">ifelse</span>(<span class="kw">length</span>(.x)&gt;<span class="dv">10</span>, <span class="kw">mean</span>(.x), <span class="ot">NA</span>), <span class="dt">stand =</span> F) +<span class="st"> </span>
<span class="st">                </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">"bottom"</span>)

<span class="kw">print</span>(plJo, <span class="dt">pages =</span> <span class="dv">1</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss10-1.png" width="1152" style="display:block; margin: auto"> Here we have exploited the fact that <code>check2D</code> is vectorized wrt the <code>x1</code> argument: when <code>x1</code> is list of variable names and argument <code>x2</code> is left unspecified, <code>check2D</code> will produce a plot for each unique pair of variables in <code>x1</code>. Another thing to notice is that we set <code>stand = F</code>, otherwise <code>l_gridCheck2D</code> would try to standardise the pinball losses using the loss calculated using the simulated responses, but we have no simulations (and, even if we had some, it is not clear whether such a stardardization would make sense in this case). The plots show that the loss is changing with <code>x</code> and increasing with <code>fac</code>, as expected (see how <code>datL</code> and <code>datT</code> have been generated).</p>
<p>The loss-based checks can of course be performed using standard (probabilistic) GAMs, for instance:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fitG &lt;-<span class="st"> </span><span class="kw"><a href="../reference/gamV.html">gamV</a></span>(<span class="kw">list</span>(ob ~<span class="st"> </span><span class="kw">s</span>(x) +<span class="st"> </span><span class="kw">s</span>(y) +<span class="st"> </span><span class="kw">s</span>(z) +<span class="st"> </span>fac, ~<span class="st"> </span>fac), <span class="dt">data =</span> datL, <span class="dt">family =</span> gaulss, 
            <span class="dt">aViz =</span> <span class="kw">list</span>(<span class="dt">newdata =</span> datT))</code></pre></div>
<p>Then we can, for example, check how the Mean Squared Error (MSE) changes across <code>x</code> by doing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ck &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(fitG, <span class="dt">x =</span> <span class="st">"x"</span>, <span class="dt">type =</span> <span class="st">"y"</span>, 
              <span class="dt">trans =</span>  function(x, ...) 
                (x -<span class="st"> </span><span class="kw">predict</span>(fitG, <span class="dt">newdata =</span> datT)[ , <span class="dv">1</span>])^<span class="dv">2</span>) <span class="co"># Raw residuals^2 on test set</span>

ck +<span class="st"> </span><span class="kw">geom_smooth</span>() +<span class="st"> </span>
<span class="st">     </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(<span class="dt">gridFun =</span> function(x, ...) <span class="kw">ifelse</span>(<span class="kw">length</span>(x) &gt;<span class="st"> </span><span class="dv">5</span>, <span class="kw">mean</span>(x), <span class="ot">NA</span>), <span class="dt">level =</span> <span class="dv">0</span>) +<span class="st"> </span>
<span class="st">     </span><span class="kw"><a href="../reference/l_rug.html">l_rug</a></span>() +<span class="st"> </span><span class="kw">ylab</span>(<span class="st">"MSE"</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss12-1.png" width="700" style="display:block; margin: auto"></p>
<p>One <strong>important</strong> thing to notice is that, if we had some simulated responses in the object, that is if we do:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fitG &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getViz.html">getViz</a></span>(fitG, <span class="dt">nsim =</span> <span class="dv">100</span>, <span class="dt">newdata =</span> datT)</code></pre></div>
<p>then <code>check1D</code> would give us:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ck &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(fitG, <span class="dt">x =</span> <span class="st">"x"</span>, <span class="dt">type =</span> <span class="st">"y"</span>, 
              <span class="dt">trans =</span>  function(x, ...) 
                (x -<span class="st"> </span><span class="kw">predict</span>(fitG, <span class="dt">newdata =</span> datT)[ , <span class="dv">1</span>])^<span class="dv">2</span>) <span class="co"># Raw residuals^2 on test set</span>

ck +<span class="st"> </span><span class="kw">geom_smooth</span>() +<span class="st"> </span>
<span class="st">     </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(<span class="dt">gridFun =</span> function(x, ...) <span class="kw">ifelse</span>(<span class="kw">length</span>(x) &gt;<span class="st"> </span><span class="dv">5</span>, <span class="kw">mean</span>(x), <span class="ot">NA</span>), <span class="dt">level =</span> <span class="dv">0</span>) +<span class="st"> </span>
<span class="st">     </span><span class="kw"><a href="../reference/l_rug.html">l_rug</a></span>() +<span class="st"> </span><span class="kw">ylab</span>(<span class="st">"MSE"</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss14-1.png" width="700" style="display:block; margin: auto"> where the small black points are the MSEs calculated by <code>l_gridCheck1D</code> using the <code>nsim</code> vectors of binned simulated response. These are clearly not useful in this case and we can avoid plotting them by setting the <code>showReps</code> argument in <code>l_gridCheck1D</code> to <code>FALSE</code>. But the call the <code>check1D</code> above would still be quite slow, because the <code>trans</code> function is applied to all the <code>nsim</code> vectors of responses. To avoid this we can set <code>useSim = FALSE</code> in the call to <code>check1D</code>, which make so that the simulations are ignored by <code>check1D</code> and all graphical layers (e.g. <code>l_gridCheck1D</code>). For instance:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ck &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check1D.html">check1D</a></span>(fitG, <span class="dt">x =</span> <span class="st">"x"</span>, <span class="dt">type =</span> <span class="st">"y"</span>, 
              <span class="dt">trans =</span>  function(x, ...) 
                <span class="kw">abs</span>(x -<span class="st"> </span><span class="kw">predict</span>(fitG, <span class="dt">newdata =</span> datT)[ , <span class="dv">1</span>]), <span class="co"># Absolute error on test set</span>
              <span class="dt">useSim =</span> <span class="ot">FALSE</span>) <span class="co"># &lt;- avoid using simulations</span>

ck +<span class="st"> </span><span class="kw">geom_smooth</span>() +<span class="st"> </span>
<span class="st">     </span><span class="kw"><a href="../reference/l_gridCheck1D.html">l_gridCheck1D</a></span>(<span class="dt">gridFun =</span> function(x, ...) <span class="kw">ifelse</span>(<span class="kw">length</span>(x) &gt;<span class="st"> </span><span class="dv">5</span>, <span class="kw">mean</span>(x), <span class="ot">NA</span>), <span class="dt">level =</span> <span class="dv">0</span>) +<span class="st"> </span>
<span class="st">     </span><span class="kw"><a href="../reference/l_rug.html">l_rug</a></span>() +<span class="st"> </span><span class="kw">ylab</span>(<span class="st">"Mean Absolute Error (MAE)"</span>)</code></pre></div>
<p><img src="BayesPost_files/figure-html/checkLoss15-1.png" width="700" style="display:block; margin: auto"> The <code>useSim</code> argument is available also in <code>check0D</code> and <code>check2D</code>.</p>
</div>
</div>
<div id="references" class="section level1">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<p>Bowman, D. W (2018). Graphics for uncertainty. Journal of the Royal Statistical Society: Series A.</p>
<p>Fasiolo, M., Goude, Y., Nedellec, R. and Wood, S.N, (2017). Fast calibrated additive quantile regression. arXiv preprint arXiv:1707.03307.</p>
<p>Fasiolo, M., Nedellec, R., Goude, Y. and Wood, S.N. (2018). Scalable visualisation methods for modern Generalized Additive Models. arXiv preprint arXiv:1809.10632.</p>
<p>Gabry, J., Simpson, D., Vehtari, A., Betancourt, M. and Gelman, A. (2018). Visualization in Bayesian workflow. Journal of the Royal Statistical Society: Series A.</p>
<p>Koenker, R. (2005). Quantile regression. Number 38. Cambridge university press.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#posterior-simulation-and-checking-methods">Posterior simulation and checking methods</a><ul class="nav nav-pills nav-stacked">
<li><a href="#smooth-effects-simulations">Smooth effects simulations</a></li>
      <li><a href="#bayesian-posterior-predictive-checks">Bayesian posterior predictive checks</a></li>
      <li><a href="#generating-raw-predictive-posterior-simulations">Generating “raw” predictive posterior simulations</a></li>
      <li><a href="#quantifying-prediction-error-under-custom-loss-functions">Quantifying prediction error under custom loss functions</a></li>
      </ul>
</li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Matteo Fasiolo, Raphael Nedellec.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
